use crate::ascii_mapping::{AsciiConfig, Charset};
use std::error::Error;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use serde::{Deserialize, Serialize};

pub trait AsciiArtOutputFormat {
    fn write_to(&self, writer: &mut File, ascii_art: &str, config: &AsciiConfig) -> Result<(), Box<dyn Error>>;
    fn file_extension(&self) -> &str;
}

pub struct TxtFormat;
pub struct JsonFormat;

impl AsciiArtOutputFormat for TxtFormat {
    fn write_to(&self, writer: &mut File, ascii_art: &str, ascii_config: &AsciiConfig) -> Result<(), Box<dyn Error>> {
        writer.write_all(ascii_art.as_bytes())?;

        let charset_str = if ascii_config.charset == Charset::CUSTOM {
            &ascii_config.custom_charset
        } else {
            ascii_config.charset.as_str()
        };

        writeln!(writer, "\n{}", "-".repeat(50))?;
        writeln!(writer, "Generated by ASCII Art Generator v{}", env!("CARGO_PKG_VERSION"))?;
        writeln!(writer, "Charset: {}, Enable Color: {}, Invert Output: {}", charset_str, ascii_config.color, ascii_config.invert)?;

        Ok(())
    }

    fn file_extension(&self) -> &str {
        "txt"
    }
}

#[derive(Serialize, Deserialize)]
struct AsciiArtJson {
    info: String,
    version: String,
    config: AsciiConfigJson,
    ascii_art: String,
}

#[derive(Serialize, Deserialize)]
struct AsciiConfigJson {
    width: u32,
    height: u32,
    gamma: f32,
    charset: String,
    color_enable: bool,
    invert_output: bool,
}

impl AsciiArtOutputFormat for JsonFormat {
    fn write_to(&self, writer: &mut File, ascii_art: &str, config: &AsciiConfig) -> Result<(), Box<dyn Error>> {
        let charset_str = if config.charset == Charset::CUSTOM {
            config.custom_charset.clone()
        } else {
            config.charset.as_str().to_string()
        };

        let actual_height = if config.height == 0 {
            count_lines(ascii_art)
        } else { 
            config.height
        };

        let json_data = AsciiArtJson {
            info: "Generated by ASCII Art Generator".to_string(),
            version: env!("CARGO_PKG_VERSION").to_string(),
            config: AsciiConfigJson {
                width: config.width,
                height: actual_height,
                gamma: config.gamma,
                charset: charset_str,
                color_enable: config.color,
                invert_output: config.invert,
            },
            ascii_art: ascii_art.to_string()
        };

        let json_string = serde_json::to_string_pretty(&json_data)?;

        writer.write_all(json_string.as_bytes())?;
        writeln!(writer)?;

        Ok(())
    }

    fn file_extension(&self) -> &str {
        "json"
    }
}

fn count_lines(s: &str) -> u32 {
    if s.is_empty() {
        0
    } else {
        s.chars().filter(|&c| c == '\n').count() as u32
    }
}

pub struct OutputHandler {
    format: Box<dyn AsciiArtOutputFormat>,
}

impl OutputHandler {
    pub fn new(format: Box<dyn AsciiArtOutputFormat>) -> Self {
        Self {format}
    }

    pub fn from_path(mut output_path: String) -> Result<(Self, String), Box<dyn Error>> {
        let mut path = PathBuf::from(&output_path);

        // 检查是否有扩展名
        let has_extension = path.extension().is_some();

        // 如果没有扩展名，添加默认扩展名".txt"
        let format = if !has_extension {
            let default_format = TxtFormat;
            path.set_extension(default_format.file_extension());
            output_path = path.to_string_lossy().into();
            Box::new(default_format) as Box<dyn AsciiArtOutputFormat>
        } else {
            // 根据扩展名选择格式
            match path.extension().and_then(|s| s.to_str()) {
                Some("txt") => Box::new(TxtFormat) as Box<dyn AsciiArtOutputFormat>,
                Some("json") => Box::new(JsonFormat) as Box<dyn AsciiArtOutputFormat>,
                Some(ext) => return Err(format!("Unsupported file extension: .{}", ext).into()),
                None => return Err("Failed to parse file extension".into()),
            }
        };

        Ok((Self::new(format), output_path))
    }

    pub fn save_ascii_art_to_file(&self, ascii_art: &str, output_path: &str, ascii_config: &AsciiConfig) -> Result<(), Box<dyn Error>> {
        let mut file = File::create(output_path)?;
        self.format.write_to(&mut file, ascii_art, ascii_config)?;

        println!("ASCII Art saved to {}", output_path);
        Ok(())
    }
}
